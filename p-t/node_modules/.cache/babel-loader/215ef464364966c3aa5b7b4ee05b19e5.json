{"ast":null,"code":"/*!\nFullCalendar Moment Plugin v4.3.0\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\nimport * as momentNs from 'moment';\nimport { createPlugin, Calendar } from '@fullcalendar/core';\nvar moment = momentNs; // the directly callable function\n\nfunction toMoment(date, calendar) {\n  if (!(calendar instanceof Calendar)) {\n    throw new Error('must supply a Calendar instance');\n  }\n\n  return convertToMoment(date, calendar.dateEnv.timeZone, null, calendar.dateEnv.locale.codes[0]);\n}\n\nfunction toDuration(fcDuration) {\n  return moment.duration(fcDuration); // moment accepts all the props that fc.Duration already has!\n}\n\nfunction formatWithCmdStr(cmdStr, arg) {\n  var cmd = parseCmdStr(cmdStr);\n\n  if (arg.end) {\n    var startMom = convertToMoment(arg.start.array, arg.timeZone, arg.start.timeZoneOffset, arg.localeCodes[0]);\n    var endMom = convertToMoment(arg.end.array, arg.timeZone, arg.end.timeZoneOffset, arg.localeCodes[0]);\n    return formatRange(cmd, createMomentFormatFunc(startMom), createMomentFormatFunc(endMom), arg.separator);\n  }\n\n  return convertToMoment(arg.date.array, arg.timeZone, arg.date.timeZoneOffset, arg.localeCodes[0]).format(cmd.whole); // TODO: test for this\n}\n\nvar main = createPlugin({\n  cmdFormatter: formatWithCmdStr\n});\n\nfunction createMomentFormatFunc(mom) {\n  return function (cmdStr) {\n    return cmdStr ? mom.format(cmdStr) : ''; // because calling with blank string results in ISO8601 :(\n  };\n}\n\nfunction convertToMoment(input, timeZone, timeZoneOffset, locale) {\n  var mom;\n\n  if (timeZone === 'local') {\n    mom = moment(input);\n  } else if (timeZone === 'UTC') {\n    mom = moment.utc(input);\n  } else if (moment.tz) {\n    mom = moment.tz(input, timeZone);\n  } else {\n    mom = moment.utc(input);\n\n    if (timeZoneOffset != null) {\n      mom.utcOffset(timeZoneOffset);\n    }\n  }\n\n  mom.locale(locale);\n  return mom;\n}\n\nfunction parseCmdStr(cmdStr) {\n  var parts = cmdStr.match(/^(.*?)\\{(.*)\\}(.*)$/); // TODO: lookbehinds for escape characters\n\n  if (parts) {\n    var middle = parseCmdStr(parts[2]);\n    return {\n      head: parts[1],\n      middle: middle,\n      tail: parts[3],\n      whole: parts[1] + middle.whole + parts[3]\n    };\n  } else {\n    return {\n      head: null,\n      middle: null,\n      tail: null,\n      whole: cmdStr\n    };\n  }\n}\n\nfunction formatRange(cmd, formatStart, formatEnd, separator) {\n  if (cmd.middle) {\n    var startHead = formatStart(cmd.head);\n    var startMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator);\n    var startTail = formatStart(cmd.tail);\n    var endHead = formatEnd(cmd.head);\n    var endMiddle = formatRange(cmd.middle, formatStart, formatEnd, separator);\n    var endTail = formatEnd(cmd.tail);\n\n    if (startHead === endHead && startTail === endTail) {\n      return startHead + (startMiddle === endMiddle ? startMiddle : startMiddle + separator + endMiddle) + startTail;\n    }\n  }\n\n  var startWhole = formatStart(cmd.whole);\n  var endWhole = formatEnd(cmd.whole);\n\n  if (startWhole === endWhole) {\n    return startWhole;\n  } else {\n    return startWhole + separator + endWhole;\n  }\n}\n\nexport default main;\nexport { toDuration, toMoment };","map":null,"metadata":{},"sourceType":"module"}